Python 3.2.3 (default, Oct 18 2012, 01:38:25) 
[GCC 4.2.1 Compatible Apple Clang 4.1 ((tags/Apple/clang-421.11.66))] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> from sympy import Symbol
>>> from sympy import symbols
>>> a11, a12, a21, a22, b1, b2, c1, c2 = symbols('a11, a12, a21, a22, b1, b2, c1, c2')
>>> a11
a11
>>> numer = -b2*c2*a11**3*a22**3 + 3*a12*c2*a11**2*a22**2*b*a21
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'b' is not defined
>>> numer = -b2*c2*a11**3*a22**3 + 3*a12*c2*a11**2*a22**2*b2*a21
>>> numer
-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2
>>> numer = -b2*c2*a11**3*a22**3 + 3*a12*c2*a11**2*a22**2*b2*a21 -3*a12**2*c2*a11*a22*b2*a21**2 + a12**3*b2*c2*a21**3
>>> numer
-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2 - 3*a11*a12**2*a21**2*a22*b2*c2 + a12**3*a21**3*b2*c2
>>> pprint(numer)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'pprint' is not defined
>>> from sympy import pprint
>>> pprint(numer)
     3    3              2            2                  2    2                3    3      
- a₁₁ ⋅a₂₂ ⋅b₂⋅c₂ + 3⋅a₁₁ ⋅a₁₂⋅a₂₁⋅a₂₂ ⋅b₂⋅c₂ - 3⋅a₁₁⋅a₁₂ ⋅a₂₁ ⋅a₂₂⋅b₂⋅c₂ + a₁₂ ⋅a₂₁ ⋅b₂⋅c₂
>>> numer.expand()
-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2 - 3*a11*a12**2*a21**2*a22*b2*c2 + a12**3*a21**3*b2*c2
>>> numer.simplify()
b2*c2*(-a11**3*a22**3 + 3*a11**2*a12*a21*a22**2 - 3*a11*a12**2*a21**2*a22 + a12**3*a21**3)
>>> denom = a11**3*a22**4 - 3 * a12*a11**2*a22**3*a21 + 3*a12**2*a11*a22**2*a21**2 - a12**3*a22*a21**3
>>> pprint(denom)
   3    4        2            3            2    2    2      3    3    
a₁₁ ⋅a₂₂  - 3⋅a₁₁ ⋅a₁₂⋅a₂₁⋅a₂₂  + 3⋅a₁₁⋅a₁₂ ⋅a₂₁ ⋅a₂₂  - a₁₂ ⋅a₂₁ ⋅a₂₂
>>> r = numer / denom
Help on Add in module sympy.core.add object:

class Add(sympy.core.operations.AssocOp)
 |  Method resolution order:
 |      Add
 |      sympy.core.operations.AssocOp
 |      sympy.core.expr.Expr
 |      sympy.core.basic.Basic
 |      sympy.core.evalf.EvalfMixin
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __neg__(self)
 |      sympy.core.operations.AssocOp
 |      sympy.core.expr.Expr
 |      sympy.core.basic.Basic
 |      sympy.core.evalf.EvalfMixin
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __neg__(self)
 |  
 |  as_coeff_Add(self)
 |      Efficiently extract the coefficient of a summation.
 |  
 |  as_coeff_add(*args, **kw_args)
 |      Returns a tuple (coeff, args) where self is treated as an Add and coeff
 |      is the Number term and args is a tuple of all other terms.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy.abc import x, y
 |      >>> (7 + 3*x).as_coeff_add()
 |      (7, (3*x,))
 |      >>> (7*x).as_coeff_add()
 |      (0, (7*x,))
 |  
 |  as_coefficients_dict(a)
 |      Return a dictionary mapping terms to their Rational coefficient.
 |      Since the dictionary is a defaultdict, inquiries about terms which
 |      were not present will return a coefficient of 0. If an expression is
 |      not an Add it is considered to have a single term.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy.abc import a, x
 |      >>> (3*x + a*x + 4).as_coefficients_dict()
 |      {1: 4, x: 3, a*x: 1}
 |      >>> _[a]
 |      0
 |      >>> (3*a*x).as_coefficients_dict()
 |      {a*x: 3}
 |  
 |  as_content_primitive(self, radical=False)
 |      Return the tuple (R, self/R) where R is the positive Rational
 |      extracted from self. If radical is True (default is False) then
 |      common radicals will be removed and included as a factor of the
 |      primitive expression.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy import sqrt
 |      >>> (3 + 3*sqrt(2)).as_content_primitive()
 |      (3, 1 + sqrt(2))
 |      
 |      Radical content can also be factored out of the primitive:
 |      
 |      >>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)
 |      (2, sqrt(2)*(1 + 2*sqrt(5)))
 |      
 |      See docstring of Expr.as_content_primitive for more examples.
 |  
 |  as_numer_denom(self)
 |  
 |  as_real_imag(self, deep=True, **hints)
 |      returns a tuple represeting a complex numbers
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy import I
 |      >>> (7 + 9*I).as_real_imag()
 |      (7, 9)
 |  
 |  as_two_terms(*args, **kw_args)
 |      Return head and tail of self.
 |      
 |      This is the most efficient way to get the head and tail of an
 |      expression.
 |      
 |      - if you want only the head, use self.args[0];
 |      - if you want to process the arguments of the tail then use
 |        self.as_coef_add() which gives the head and a tuple containing
 |        the arguments of the tail when treated as an Add.
 |      - if you want the coefficient when self is treated as a Mul
 |        then use self.as_coeff_mul()[0]
 |      
 |      >>> from sympy.abc import x, y
 |      >>> (3*x*y).as_two_terms()
 |      (3, x*y)
 |  
 |  extract_leading_order(*args, **kw_args)
 |      Returns the leading term and it's order.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy.abc import x
 |      >>> (x + 1 + 1/x**5).extract_leading_order(x)
 |      ((x**(-5), O(x**(-5))),)
 |      >>> (1 + x).extract_leading_order(x)
 |      ((1, O(1)),)
 |      >>> (x + x**2).extract_leading_order(x)
 |      ((x, O(x)),)
 |  
 |  getO(self)
 |  
 |  matches = _matches_commutative(self, expr, repl_dict={})
 |      Matches Add/Mul "pattern" to an expression "expr".
 |      
 |      repl_dict ... a dictionary of (wild: expression) pairs, that get
 |                    returned with the results
 |      
 |      This function is the main workhorse for Add/Mul.
 |      
 |      For instance:
 |      
 |      >>> from sympy import symbols, Wild, sin
 |      >>> a = Wild("a")
 |      >>> b = Wild("b")
 |      >>> c = Wild("c")
 |      >>> x, y, z = symbols("x y z")
 |      >>> (a+sin(b)*c)._matches_commutative(x+sin(y)*z)
 |      {a_: x, b_: y, c_: z}
 |      
 |      In the example above, "a+sin(b)*c" is the pattern, and "x+sin(y)*z" is
 |      the expression.
 |      
 |      The repl_dict contains parts that were already matched. For example
 |      here:
 |      
 |      >>> (x+sin(b)*c)._matches_commutative(x+sin(y)*z, repl_dict={a: x})
 |      {a_: x, b_: y, c_: z}
 |      
 |      the only function of the repl_dict is to return it in the
 |      result, e.g. if you omit it:
 |      
 |      >>> (x+sin(b)*c)._matches_commutative(x+sin(y)*z)
 |      {b_: y, c_: z}
 |      
 |      the "a: x" is not returned in the result, but otherwise it is
 |      equivalent.
 |  
 |  primitive(self)
 |      Return ``(R, self/R)`` where ``R``` is the Rational GCD of ``self```.
 |      
 |      ``R`` is collected only from the leading coefficient of each term.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy.abc import x, y
 |      
 |      >>> (2*x + 4*y).primitive()
 |      (2, x + 2*y)
 |      
 |      >>> (2*x/3 + 4*y/9).primitive()
 |      (2/9, 3*x + 2*y)
 |      
 |      >>> (2*x/3 + 4.2*y).primitive()
 |      (1/3, 2*x + 12.6*y)
 |      
 |      No subprocessing of term factors is performed:
 |      
 |      >>> ((2 + 2*x)*x + 2).primitive()
 |      (1, x*(2*x + 2) + 2)
 |      
 |      Recursive subprocessing can be done with the as_content_primitive()
 |      method:
 |      
 |      >>> ((2 + 2*x)*x + 2).as_content_primitive()
 |      (2, x*(x + 1) + 1)
 |      
 |      See also: primitive() function in polytools.py
 |  
 |  removeO(self)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  class_key(cls) from sympy.core.assumptions.ManagedProperties
 |      Nice order of classes
 |  
 |  flatten(cls, seq) from sympy.core.assumptions.ManagedProperties
 |      Takes the sequence "seq" of nested Adds and returns a flatten list.
 |      
 |      Returns: (commutative_part, noncommutative_part, order_symbols)
 |      
 |      Applies associativity, all terms are commutable with respect to
 |      addition.
 |      
 |      NB: the removal of 0 is already handled by AssocOp.__new__
 |      
 |      See also
 |      ========
 |      
 |      sympy.core.mul.Mul.flatten
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  default_assumptions = {}
 |  
 |  identity = 0
 |  
 |  
 |  is_Add = True
 |      expression.
 |      
 |      - if you want only the head, use self.args[0];
 |      - if you want to process the arguments of the tail then use
 |        self.as_coef_add() which gives the head and a tuple containing
 |        the arguments of the tail when treated as an Add.
 |      - if you want the coefficient when self is treated as a Mul
 |        then use self.as_coeff_mul()[0]
 |      
 |      >>> from sympy.abc import x, y
 |      >>> (3*x*y).as_two_terms()
 |      (3, x*y)
 |  
 |  extract_leading_order(*args, **kw_args)
 |      Returns the leading term and it's order.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy.abc import x
 |      >>> (x + 1 + 1/x**5).extract_leading_order(x)
 |      ((x**(-5), O(x**(-5))),)
 |      >>> (1 + x).extract_leading_order(x)
 |      ((1, O(1)),)
 |      >>> (x + x**2).extract_leading_order(x)
 |      ((x, O(x)),)
 |  
 |  getO(self)
 |  
 |  matches = _matches_commutative(self, expr, repl_dict={})
 |      Matches Add/Mul "pattern" to an expression "expr".
 |      
 |      repl_dict ... a dictionary of (wild: expression) pairs, that get
 |                    returned with the results
 |      
 |      This function is the main workhorse for Add/Mul.
 |      
 |      For instance:
 |      
 |      >>> from sympy import symbols, Wild, sin
 |      >>> a = Wild("a")
 |      >>> b = Wild("b")
 |      >>> c = Wild("c")
 |      >>> x, y, z = symbols("x y z")
 |      >>> (a+sin(b)*c)._matches_commutative(x+sin(y)*z)
 |      {a_: x, b_: y, c_: z}
 |      
 |      In the example above, "a+sin(b)*c" is the pattern, and "x+sin(y)*z" is
 |      the expression.
 |      
 |      The repl_dict contains parts that were already matched. For example
 |      here:
 |      
 |      >>> (x+sin(b)*c)._matches_commutative(x+sin(y)*z, repl_dict={a: x})
 |      {a_: x, b_: y, c_: z}
 |      
 |      the only function of the repl_dict is to return it in the
 |      result, e.g. if you omit it:
 |      
 |      >>> (x+sin(b)*c)._matches_commutative(x+sin(y)*z)
 |      {b_: y, c_: z}
 |      
 |      the "a: x" is not returned in the result, but otherwise it is
 |      equivalent.
 |  
 |  primitive(self)
 |      Return ``(R, self/R)`` where ``R``` is the Rational GCD of ``self```.
 |      
 |      ``R`` is collected only from the leading coefficient of each term.
 |      
 |      Examples
 |      ========
 |      
 |      >>> from sympy.abc import x, y
 |      
 |      >>> (2*x + 4*y).primitive()
 |      (2, x + 2*y)
 |      
 |      >>> (2*x/3 + 4*y/9).primitive()
 |      (2/9, 3*x + 2*y)
 |      
 |      >>> (2*x/3 + 4.2*y).primitive()
 |      (1/3, 2*x + 12.6*y)
 |      
 |      No subprocessing of term factors is performed:
 |      
 |      >>> ((2 + 2*x)*x + 2).primitive()
 |      (1, x*(2*x + 2) + 2)
 |      
 |      Recursive subprocessing can be done with the as_content_primitive()
 |      method:
 |      
 |      >>> ((2 + 2*x)*x + 2).as_content_primitive()
 |      (2, x*(x + 1) + 1)
 |      
 |      See also: primitive() function in polytools.py
 |  
 |  removeO(self)
 |  
 |  ----------------------------------------------------------------------
 |  Class methods defined here:
 |  
 |  class_key(cls) from sympy.core.assumptions.ManagedProperties
 |      Nice order of classes
 |  
 |  flatten(cls, seq) from sympy.core.assumptions.ManagedProperties
 |      Takes the sequence "seq" of nested Adds and returns a flatten list.
 |      
 |      Returns: (commutative_part, noncommutative_part, order_symbols)
 |      
 |      Applies associativity, all terms are commutable with respect to
 |      addition.
 |      
 |      NB: the removal of 0 is already handled by AssocOp.__new__
 |      
 |      See also
 |      ========
 |      
 |      sympy.core.mul.Mul.flatten
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  default_assumptions = {}
 |  
 |  identity = 0
 |  
 |  
 |  is_Add = True
 |  
 |  ----------------------------------------------------------------------
 |  Class methods inherited from sympy.core.operations.AssocOp:
 |  
 |  make_args(cls, expr) from sympy.core.assumptions.ManagedProperties
 |      Return a sequence of elements `args` such that cls(*args) == expr
 |      
 |      >>> from sympy import Symbol, Mul, Add
 |      >>> x, y = list(map(Symbol, 'xy'))
 |      
 |      >>> Mul.make_args(x*y)
 |      (x, y)
 |      >>> Add.make_args(x*y)
 |      (x*y,)
 |      >>> set(Add.make_args(x*y + y)) == set([y, x*y])
 |      True
 |  
 |  ----------------------------------------------------------------------
 |  Static methods inherited from sympy.core.operations.AssocOp:
 |  
 |  __new__(*args, **kw_args)
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from sympy.core.operations.AssocOp:
 |  
 |  is_commutative
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sympy.core.expr.Expr:
 |  
 |  __abs__(self)
 |  
 |  __add__(a, b)
 |  
 |  __call__(self, *args)
 |  
 |  __complex__(self)
 |  
 |  __div__(a, b)
 |  
 |  __float__(self)
 |  
 |  __ge__(a, b)
 |  
 |  __gt__(a, b)
 |  
 |  __int__(self)
 |  
 |  __le__(a, b)
 |  
 |  __lt__(a, b)
 |  
 |  __mod__(a, b)
 |  
 |  __mul__(a, b)
 |  
 |  __pos__(self)
 |  
 |  __pow__(a, b)
 |  
 |  __radd__(a, b)
 |  
 |  __rdiv__(a, b)
 |  
 |  __rmod__(a, b)
 |  
 |  __rmul__(a, b)
 |  
 |  __rpow__(a, b)
 |  
 |  __rsub__(a, b)
 |  
 |  __rtruediv__ = __rdiv__(a, b)
 |  
 |  __sub__(a, b)
 |  
 |  __truediv__ = __div__(a, b)
 |  
 |  adjoint(self)
 |  
 |  apart(self, x=None, **args)
 |      See the apart function in sympy.polys
 |  
 |  args_cnc(self, cset=False, warn=True)
 |      Return [commutative factors, non-commutative factors] of self.
 |      
 |      self is treated as a Mul and the ordering of the factors is maintained.
 |      If ``cset`` is True the commutative factors will be returned in a set.
 |      If there were repeated factors (as may happen with an unevaluated Mul)
 |      then an error will be raised unless it is explicitly supressed by
 |      setting ``warn`` to False.
 |      
 |      Note: -1 is always separated from a Number.
 |      
 |      >>> from sympy import symbols, oo
 |      >>> A, B = symbols('A B', commutative=0)
 |      >>> x, y = symbols('x y')
 |      >>> (-2*x*y).args_cnc()
 |      [[-1, 2, x, y], []]
 |      >>> (-2.5*x).args_cnc()
 |      [[-1, 2.5, x], []]
 |      >>> (-2*x*A*B*y).args_cnc()
 |      [[-1, 2, x, y], [A, B]]
 |      >>> (-2*x*y).args_cnc(cset=True)
 |      [set([-1, 2, x, y]), []]
 |      
 |      The arg is always treated as a Mul:
 |      
 |      >>> (-2 + x + A).args_cnc()
 |      [[], [x - 2 + A]]
 |      >>> (-oo).args_cnc() # -oo is a singleton
 |      [[-1, oo], []]
 |  
 |  as_base_exp(self)
 |  
 |  as_coeff_Mul(self, rational=False)
 |      Efficiently extract the coefficient of a product.
 |  
 |  as_coeff_exponent(self, x)
>>> r
(-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2 - 3*a11*a12**2*a21**2*a22*b2*c2 + a12**3*a21**3*b2*c2)/(a11**3*a22**4 - 3*a11**2*a12*a21*a22**3 + 3*a11*a12**2*a21**2*a22**2 - a12**3*a21**3*a22)
>>> pprint(r)
     3    3              2            2                  2    2                3    3      
- a₁₁ ⋅a₂₂ ⋅b₂⋅c₂ + 3⋅a₁₁ ⋅a₁₂⋅a₂₁⋅a₂₂ ⋅b₂⋅c₂ - 3⋅a₁₁⋅a₁₂ ⋅a₂₁ ⋅a₂₂⋅b₂⋅c₂ + a₁₂ ⋅a₂₁ ⋅b₂⋅c₂
───────────────────────────────────────────────────────────────────────────────────────────
              3    4        2            3            2    2    2      3    3              
           a₁₁ ⋅a₂₂  - 3⋅a₁₁ ⋅a₁₂⋅a₂₁⋅a₂₂  + 3⋅a₁₁⋅a₁₂ ⋅a₂₁ ⋅a₂₂  - a₁₂ ⋅a₂₁ ⋅a₂₂          
>>> r.simplify((
... 
... )
... )
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: simplify() takes exactly 1 positional argument (2 given)
>>> r.simplify()
-b2*c2/a22
>>> numer
-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2 - 3*a11*a12**2*a21**2*a22*b2*c2 + a12**3*a21**3*b2*c2
>>> numer.collect()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: collect() takes at least 2 arguments (1 given)
>>> numer.collect(None)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/opt/local/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/site-packages/sympy/core/expr.py", line 2750, in collect
    return collect(self, syms, func, evaluate, exact, distribute_order_term)
  File "/opt/local/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/site-packages/sympy/simplify/simplify.py", line 448, in collect
    syms = [ expand_power_base(syms, deep=False) ]
  File "/opt/local/Library/Frameworks/Python.framework/Versions/3.2/lib/python3.2/site-packages/sympy/core/function.py", line 1916, in expand_power_base
    return sympify(expr).expand(deep=deep, log=False, mul=False,
AttributeError: 'NoneType' object has no attribute 'expand'
>>> numer.collect(denum)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'denum' is not defined
>>> numer.collect(denom)
-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2 - 3*a11*a12**2*a21**2*a22*b2*c2 + a12**3*a21**3*b2*c2
>>> numer.combsimp()
-b2*c2*(a11*a22 - a12*a21)**3
>>> help(numer)

>>> numer.as_coeff_mul()
(1, (-a11**3*a22**3*b2*c2 + 3*a11**2*a12*a21*a22**2*b2*c2 - 3*a11*a12**2*a21**2*a22*b2*c2 + a12**3*a21**3*b2*c2,))
>>> numer.combsimp().as_coeff_mul()
(-1, (b2, c2, (a11*a22 - a12*a21)**3))
